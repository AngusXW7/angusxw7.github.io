[{"categories":["C++"],"content":"C Keywords","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"Keyword in C! Today we’ll talk about keywords in C ","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/:0:0","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"What are keywords So before we talk about keywords, first we need to know what the definition of a keyword is. Keywords are predefined reserved identifiers that have a special meaning and cannot be used as identifiers in a program. Some of our common keywords are ","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/:1:0","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"Keywords? Keyword Listkeywords \"\rKeyword List\r This is a list of C++ 98/03 keywords I found on the web, where the 32 keywords in C are marked in red. In C++ 11, there are 73 keywords, and the new ones are alignas, alignof, char16_t, char32_t, constexpr, decltype, noexpect, nullptr, static_assert, thread_local. Next we have a brief explanation of the more commonly used keywords ","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/:1:1","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"auto This keyword usage is just like its name, it will automatically shorten the data type of the variable, but we should note that not every compiler supports auto auto x=1; // Here the variable x is initialized using the integer 1, then the type of x is inferred to be an int integer type. auto y=3.14159; // Here the variable y is initialized using the floating point number 3.14159, then the type of y is inferred to be a float floating point type. ","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/:1:2","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"***_cast The cast keyword is added after it for C++ style type conversion const_cast const_castis simplest, it removes the attributes of a const variable so that the type of data being converted can be changed dynamic_cast dynamic_cast is a top-down conversion from a parent object pointer to a derived object pointer or reference. static_cast Compared to dynamic_cast, static_cast is mostly used to convert a pointer of a derived object to a parent object, and is a bottom-up conversion. reinterpret_cast reinterpret_cast is a more dangerous type of conversion, it can convert one type to a different type, it can work on two completely unrelated type conversion ","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/:1:3","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"break 、 continue I often confuse these two keywords, in fact, we just need to understand the literal meaning, break is to stop, as the name suggests is to jump out of the current cycle, no longer continue the cycle, directly to the next step, and continue is to continue, that is to say, skip this cycle, continue the next cycle. ","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/:1:4","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"do、for、while They are part of the loop statement and are supported by both C and C++. ","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/:1:5","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"if else These two are part of the conditional statement, if means what condition is satisfied, else generally means that the condition is not satisfied. ","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/:1:6","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"public、private、protected、friend You should be familiar with these keywords private, can only be accessed in this class, derived classes and friends public, access is not restricted, any class can access protected, only this class and friend can access friend, so that it is not restricted by access rights control. In fact, the existence of friend elements destroys the encapsulation of C++, so we suggest you reduce the use of friend elements. Well, that’s all for today! Hope you like it in front of the screen! ","date":"2022-03-23","objectID":"https://angusxw7.github.io/keyword/:1:7","tags":["C++","Keyword"],"title":"C++ Keywords","uri":"https://angusxw7.github.io/keyword/"},{"categories":["C++"],"content":"C++ Class and Special members","date":"2022-03-16","objectID":"https://angusxw7.github.io/special-member/","tags":["C++","Class","memberFunctions"],"title":"Special members","uri":"https://angusxw7.github.io/special-member/"},{"categories":["C++"],"content":"C++ Class and Special members! user declares and compiler implicitly declares函数关系图 \"\ruser declares and compiler implicitly declares\r ","date":"2022-03-16","objectID":"https://angusxw7.github.io/special-member/:0:0","tags":["C++","Class","memberFunctions"],"title":"Special members","uri":"https://angusxw7.github.io/special-member/"},{"categories":["C++"],"content":"6 Special members We all know that OOP(object-oriented programming) is a feature of C++, and most of these objects have corresponding classes, and there are very important functions in the classes, which are the member functions we are going to discuss today. As we can see from the figure above, there are six special member functions, and they are. class A { public: A(); //constructor ~A(); //destructor A(const A\u0026 a); //copy constructor A(const\u0026\u0026 a); //move constructor A\u0026 operator=(const A\u0026 a); //copy assignment A\u0026 operator=(A\u0026\u0026 a); //move assignment } Combined with the text in the figure, we can easily see that when we do not declare any functions, the system will automatically declare them for us; but once we have declared them, the system will delete the automatically declared functions. To put it simply, if we don’t have one, the system uses its own; if we do, the system uses ours. Here are a few more important things in conjunction with the characteristics of the class. the constructor must not be a virtual function! Because the constructor is to create the object, and the virtual function needs to know the actual type of the object, if the constructor is defined as a virtual function, then there is no way to know the actual type of the object! the destructor function better be a virtual function! The destructor function is defined as a virtual function can be a good solution to the base class derived classes after the type conversion of the destructor operation, to avoid the destructor of the wrong object or not the destructor of the right object. ","date":"2022-03-16","objectID":"https://angusxw7.github.io/special-member/:1:0","tags":["C++","Class","memberFunctions"],"title":"Special members","uri":"https://angusxw7.github.io/special-member/"},{"categories":["C++"],"content":"Rule of zero/three/five Next let’s talk about the 0/3/5 Rules, probably based on the literal meaning of the smart you know what it is. Yes! It is that we need to add how many functions. ","date":"2022-03-16","objectID":"https://angusxw7.github.io/special-member/:2:0","tags":["C++","Class","memberFunctions"],"title":"Special members","uri":"https://angusxw7.github.io/special-member/"},{"categories":["C++"],"content":"Rule of zero The rule of zero, as the name implies, is not to define a single member function, because many times classes do not need destructors, copy/move constructors or copy/move assignments, and the compiler generates them by default to do the job just fine, so try to use the rule of zero if possible. class A { public: // Rule of zero } ","date":"2022-03-16","objectID":"https://angusxw7.github.io/special-member/:2:1","tags":["C++","Class","memberFunctions"],"title":"Special members","uri":"https://angusxw7.github.io/special-member/"},{"categories":["C++"],"content":"Rule of three If you define a copy operation, remember to override the copy constructor and the copy assignment, otherwise sometimes the compiler will call the move equation because in its opinion the move operations is cheaper than a copy. class A { public: ~A(); //destructor A(const A\u0026 a); //copy constructor A\u0026 operator=(const A\u0026 a); //copy assignment } ","date":"2022-03-16","objectID":"https://angusxw7.github.io/special-member/:2:2","tags":["C++","Class","memberFunctions"],"title":"Special members","uri":"https://angusxw7.github.io/special-member/"},{"categories":["C++"],"content":"Rule of five This rule is important, if you define a destructor yourself, then you have to define the copy constructor and copy assignment yourself, otherwise the default generated copy constructor and copy assignment will do the wrong thing; and also write the constructor and copy assignment with matching semantics. Then, for performance reasons, it is best to write the move constructor class move assignment as well. class A { public: A(); ~A(); A(const A\u0026 a); A(const\u0026\u0026 a); A\u0026 operator=(const A\u0026 a); A\u0026 operator=(A\u0026\u0026 a); } Well, that’s all I have to share today! It’s my final week of the semester, so I’m really busy. let’s steal a lazy! Heihei! ","date":"2022-03-16","objectID":"https://angusxw7.github.io/special-member/:2:3","tags":["C++","Class","memberFunctions"],"title":"Special members","uri":"https://angusxw7.github.io/special-member/"},{"categories":["C++"],"content":"A little about C pointers","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"The essence of the C languages Pointer! Hello, I’ve found time in my busy schedule to come back as promised. Today, I’ll talk about pointers. It’s said that the essence of C is pointers, but it’s also true that C should be one of the few high-level languages that can manipulate the underlying memory with pointers. I’m sure my understanding is not as deep as that of the top coders, after all, I’m just a beginner, the wording is not accurate or logic is not strict, please enlighten me ~, if there is where to say the wrong, also welcome to point out! ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:0:0","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"WHAT IS POINTER Before we expand the question, then, we need to figure out what a pointer is. We often say that a pointer is an address, and that a pointer variable is a variable used to store a memory address. As I understand it, a pointer is synonymous with your home, and a memory address is where your home actually is. When you say that a pointer points to such and such address, you are actually saying that your home is a synonym for where your home address is (that is, where your home lives). This sounds a bit like nonsense. ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:1:0","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"EXAMPLES： int* ptr= 0X12345678; int* ptr = \u0026 XW7 home; We have an int pointer ptr (my home pronoun): int* ptr ; This pointer points to (the actual address of my house): 0X12345678; // Generally speaking, memory addresses are expressed in eight bits of hexadecimal, starting with 0X in order to distinguish from binary, octal and decimal It is generally written as int* ptr = \u0026 XW7’s home; Let’s ignore this “\u0026” and read “=” as “is”, so now this sentence is saying that ptr is the home of xw7. Next, let’s say I want to invite my friend to my house for the weekend, then I just say ptr to them and they surely can’t know where my house is for no reason, right? So we’ll use “\u0026” for the address, so int* ptr = \u0026 XW7’s home now becomes ptr = 12 City 34 56th Street 78 , the actual address of my house, and again, we read “=” as “is”, XW7’s home is 78-56th street, 34th district, 12th city. This way my friends can find my house without any problem on weekends. ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:1:1","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"“*” int* *ptr // not exists int* ptr = sth ; ptr* = sth ; The symbol “*” means something different when it follows a different owner. But we won’t see int* * variableName (int* *ptr) as something that exists. We will only see int* variable name = something; or *ptr = something; char* c ; //char type pointer int* i ; //int type pointer float* f ; //float type pointer In general, if it follows a data type, like char int float, then it represents a pointer to that type char* is a pointer to a char type; int* is a int type pointer; float* is a float pointer; and so on // on 32-bit systems, all pointers are 4 bytes in size. *ptr = XW7 home ; ptr = 0X12345678; But if it’s followed by a variable name, like *ptr above, then it’s a dereference, and you have to use a pronoun. In layman’s terms, adding * to ptr means that ptr is encrypted and can only say XW7’s home, but not the exact address of 12 City 34, 56th Street, 78. That is, *ptr = XW7’s home , *ptr is XW7’s home. ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:1:2","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"CONST AND * I believe that many people have been confused by the placement of const and *, but when you get the key, you will find it very simple. You can tell what pointer constants and constant pointers are at a glance. First of all, someone may ask, What is a const? Ha ha, cosnt is actually a modifier, the thing that is modified by him can not be changed. Here I share my tips: ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:2:0","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"TIP First we list a few very common formats. const int * ptr；// 1 int const * ptr；// 2 int * const ptr；// 3 How do we distinguish them ? It is very simple, we only need to look at two things, one is * and the other is ptr; If const is immediately followed by * then there is no doubt that const modifies *ptr(content), which means that *ptr cannot be changed; //1,2 If const is immediately followed by variable name (i.e., ptr), then const modifies the variable name, which means that ptr(pointer) cannot be changed. //3 Another very important thing is that const is a “one-time thing”. If you want more than one pointer or value that cannot be changed, you have to use more than one const, e.g. const int* const ptr; // both int* and ptr are immutable const int* const p1, const p2; // int* p1 p2 are immutable ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:2:1","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"APPLICATIONS So after we know who is not changeable, what do we use them for; first we can get two more useful information from the naming statement, one is who the pointer points to, and the other is what the pointing thing contains. Let’s use the example of renting a house, where the pointer represents the house and the content inside represents the tenant. If what is pointed to cannot be changed, then it is now the landlord identity, that is, as long as it is my house, it does not matter which tenants, you can change them at will. If the content of the pointer cannot be changed, then it is now the identity of the tenant, that is to say, as long as I am renting the house, it does not matter which house, you can change it at will. ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:2:2","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"EXPANSION Further down the line, it should touch on objects and classes, let’s briefly say. const returnType functionName ( Parameter); // return type can not be modified returnType functionName (const Parameter); // incoming parameters can not be modified returnType functionName (Parameter) const; // class member parameters can not be modified ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:2:3","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"ARRAY AND * We all know that arrays are implicitly degraded to pointers when they are passed as arguments to functions, so we arbitrarily treat arrays as a kind of pointer. Here are a few confusing combinations of arrays and *. ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:3:0","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"EXAMPLES int array[]; int* p = array; *p ; // array[0] p+1 ; //array[0]address + 4 *p+1 ; //array[0]value + 1 *(p+1) ; //array[1] *（ *（p+n)+m) = p[n][m]; Suppose we have an array called array, *p =array; then. *p represents the first element of the array i.e. array[0] ; p + 1 represents the address of the first element of the array shifted back by one unit, if array is of type char the offset is 1, int the offset is 4 float the offset is 4, and so on. The address of the second element of the array is represented implicitly ; *p + 1 represents the value of the first element of the array + 1 i.e. (the value of array[0] ) + 1 ; *(p + 1 ) represents the element of the array with subscript 1, i.e. p[1] ; So we can simply derive a *(p+n) = p[n] ; // *( + ) = [] What about if it’s a multi-dimensional arrays ? It’s simple *( *(p+n)+m) = p[n][m]; ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:3:1","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"POINTER OPERATIONS Always remember that in the function __ only the next level pointer can operate the current level pointer __, you may be a little confuse, I’ll explain to you: Without * we will call it a zero-level pointer *is a first-level pointer ** is the second level pointer Here we have p *p **p; So *p can operate on p, **p can operate on *p, and so on If you are trying to read a multilevel pointer, the reading order must be from right to left. ( * (* ( * ( * (m))) is like this, You have to look at m first and then look at * (m); then look at * (* (m)); And finally look at *( * ( * (m))); ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:4:0","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["C++"],"content":"SHARE AND SUMMARY Well that’s it for today’s sharing, going to get busy. Here to share a better pointer tutorial, I hope it can be helpful to you in front of the screen. Heihei！ ","date":"2022-03-09","objectID":"https://angusxw7.github.io/c_pointer/:5:0","tags":["Pointer","C++","essence"],"title":"C++ Pointer","uri":"https://angusxw7.github.io/c_pointer/"},{"categories":["general"],"content":"The first blog of my life","date":"2022-03-02","objectID":"https://angusxw7.github.io/hello-world/","tags":["hello-world","general","others"],"title":"Hello,World！","uri":"https://angusxw7.github.io/hello-world/"},{"categories":["general"],"content":"Hello, you in front of the screen! First of all I would like to thank you for coming to my blog, this is my first attempt to build a blog and edit posts on it with makedown syntax, I hope that here you can witness my growth and my change. I hope you can join me in witnessing the process of building this blog from zero to one, from nothing to something. After half a month of preparation I finally got the infrastructure of the site all set up. I was going to send this post out on the 1st of March as the start of the month and the start of this site, which must have been a great day. It’s a pity that I’m so busy that I’ve just made some time to write this blog. I didn’t know what to call this document when I first created it and what to write about it, haha. After all, I rarely write and share things, so I’m suddenly a little bit baffled. As a programmer, I’m sure everyone starts with a “Hello World! and hopefully there will be no ‘break’ or ‘sleep’ in between. My initial idea for the content of the blog is to divide it into three main sections: Unreal Engine Game Creation, C++ Life and General, because after all, we come from a background of game software programming, learning C++ and Unreal Engine, and when we first come to an unfamiliar field, we must start with something we are familiar with in order to produce content more easily. Of course, if I find something interesting, it will be added to my blog as a new section. Well, that’s all for now, I’ve got to get busy. If you are interested in me and would like to know more about me, you can check out my profile by clicking on “About XW7\u0026” in the top right corner. I’m sure my profile will continue to be updated, after all, people are growing up, and my experience, abilities and work will get richer and richer as time goes by. Heihei！ ","date":"2022-03-02","objectID":"https://angusxw7.github.io/hello-world/:0:0","tags":["hello-world","general","others"],"title":"Hello,World！","uri":"https://angusxw7.github.io/hello-world/"},{"categories":null,"content":"This is for test. ","date":"2022-02-15","objectID":"https://angusxw7.github.io/testblog/:0:0","tags":null,"title":"TestBlog","uri":"https://angusxw7.github.io/testblog/"},{"categories":null,"content":"class XW7\u0026 struct Information { major : Game Design and Game Programming； programmingLanguage : C++ ； dream : Make a MMORPG national style game that players will naturally love(Hanbok forever god!)； personality : Tolerant, friendly, lively and cheerful, slow-acting personality, responsible, tolerant and patient, team player, always have the unexpected and creative proposals； hobbies : play games,listen to songs,travel,looking at photos taken by others, watching others eat food, and enjoying all kinds of fun, techy gadgets (e.g. drones)； favourite cities : Hainan, Zhuhai, Xi’an; … ; } struct Skills { good at C++，know part of 14/17/20 new features and Debug capability； good at Unreal Engine 4 ； master data structures and algorithms, with good programming habits； master the basic application of MySQL //CRUD； know basic grammar and simple usage of Golang； know Unreal Engine 5，have tried out the UE5 preview and is learning； know Unity3D base on the development of mobile games； know network programming，like TCP/IP and socket； know MAYA basic modelling , rendering and making videos of the modelling done by Nuke and Renderman； know Linux operating system，basic knowledge of daily using； const millions of new skills incoming!； } struct Projects { UE4 OWG_Demo； C++ XW7-Engine; Golang { log; iniProfileParser; } } struct Contact { Bilibili; Email : angusli951102@gmail.com； Github; LinkIn; QQ : 714152655; Steam; Weibo; } ","date":"2019-08-02","objectID":"https://angusxw7.github.io/about/:0:1","tags":null,"title":"About XW7\u0026","uri":"https://angusxw7.github.io/about/"}]