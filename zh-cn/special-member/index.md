# 类与成员函数

C++类与它的六种成员函数！

<!--more-->

![函数关系图](special-member-functions.png "用户创建的函数与系统默认生成的函数的关系图")

## 六大成员函数

我们都知道面向对象编程是C++的一个特点，这些对象大部分都是有对应的类的，而类中也有很重要的函数，就是我们今天要讨论的成员函数。

从上图中我们可以看出，一共有六种成员函数，他们分别是：

```
class A
{
public:
    A(); //构造函数
    ~A(); //析构函数

    A(const A& a); //复制构造函数
    A(const&& a); //移动构造函数

    A& operator=(const A& a); //复制运算符
    A& operator=(A&& a); //移动运算符
}
```

结合图中的文字我们可以很轻易地看出，当我们一个函数都不声明的时候，系统是会自动帮我们声明这些函数的；但是一旦当我们声明了这些函数以后，系统就会删除自动声明的那些函数。

简单一点来说，如果我们没有，系统就用自己的；如果我们有，系统就用我们的。

这里结合类的特性说几点比较重要的东西：

1. 构造函数一定不能是虚函数！

    因为构造函数是创造对象的，而虚函数需要知道对象的实际类型，如果构造函数被定义为虚函数了，那么就无法知道对象的实际类型了！

2. 如果有条件析构函数最好是虚函数！

    析构函数定义成了虚函数可以很好地解决父类子类进行类型转换以后的析构操作，避免造成析构了错误对象或者说没有析构该析构的对象。


## 0/3/5法则

接下来我们来说一下0/3/5法则，可能根据字面意思聪明的你就知道这是什么东西了，没错！就是我们需要添加几个函数。

### 0法则

0法则顾名思义就是一个成员函数都不要定义，因为很多时候类并不需要析构函数，复制/移动构造函数或者复制/移动运算符，编译器默认生成的就可以很好地完成任务了，所以如果有可能的话，尽量使用零规则。

```
class A
{
public:
    // 0法则
}
```


### 3法则

如果你定义了复制操作，那么要记得重写复制操作相关的方程，否则有的时候编译器会调用移动方程，因为在它看来移动操作比复制操作会好很多。

```
class A
{
public:
    ~A();//析构函数

    A(const A& a);  //复制构造函数
    A& operator=(const A& a);  //复制运算符
}
```


### 5法则

这个法则比较重要，如果说你自己定义了一个析构函数，那么你就必须要自己把复制构造函数和复制运算符也定义了，否则默认生成的复制构造函数和复制运算符会做错事情；同时还要编写具有匹配语义的构造函数和复制运算符。然后出于对性能的考虑，移动构造函数课移动运算符最好也自己同时编写。


```
class A
{
public:
    A(); 
    ~A(); 

    A(const A& a); 
    A(const&& a);

    A& operator=(const A& a); 
    A& operator=(A&& a); 
}
```


好啦，那今天就分享这么多吧！临近期末了，比较忙，偷个懒。

嘿嘿！



