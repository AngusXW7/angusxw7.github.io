# C++ 指针

C系列语言的精髓 指针！

<!--more-->

哈喽，我又在百忙之中抽出时间如约而至啦。今天来浅谈一下指针吧，都说C的精髓就是指针，不过也确实，C应该是为数不多可以凭借指针操控底层内存的高级语言了。我的理解程度肯定没有大神级别的那么深，毕竟是个刚入门的小白，用词不准确或者逻辑不严谨的话，还请多指教啦~，如果有哪里说的不对，也欢迎指出！

## 指针是什么

那展开问题之前，我们要先搞清楚指针是什么。

我们经常说，指针就是地址，指针变量是用来存放内存地址的变量的。

我的理解呢，指针就相当于你家的代名词，而内存地址就是你家实际在的地方。常说的指针指向了某某地址，其实就是在说，你家这个代名词说明了你家地址所在地（就是你家住哪）。这样讲听着有点像废话。

### 我们还是来举个例子吧：

```
int* ptr= 0X12345678;
int* ptr = & XW7的家;
```

我们有一个整形指针 **ptr** （我家代名词）：  __int* ptr__  ;

这个指针指向了（我家实际地址）：**0X12345678**; //一般情况下内存地址用八位的十六进制表示，0X开头是为了和二进制，八进制还有十进制作区分


一般写成 __int* ptr = & XW7的家__;

我们先忽略这个 “&” ，把 “=” 读作 “是” ，那么现在这句话是不是就在说 ptr 是 xw7的家。

接下来，比如我要邀请我的朋友周末来我家玩，那我光和他说 ptr 他肯定不能平白无故的知道我家在哪，对吧。

所以我们要用“&”表示地址，那么int* ptr = & XW7的家 现在就变成了 ptr = 12市34区56街78号，即我家的实际地址，同样的，我们把“=”读作“是”，XW7的家是12市34区56街78号。这样我的朋友们周末就可以顺利的找到我家了。

### “*”
```
int* *ptr //不存在
int* ptr = 什么 ;
ptr* = 什么 ;
```

"__*__"这个符号呢跟随不同的主人，就会代表不同的意思，我们俗称嫁鸡随鸡嫁狗随狗。

但是我们不会看见int* * 变量名（int* *ptr） 这种东西存在的；

我们只会看到int* 变量名 = 什么;

或者 *ptr = 什么;

```
char* c ;//char类型指针
int*  i ;//int类型指针
float* f ;//float类型指针
```

一般情况下，如果它跟的是数据类型，比如 __char int float__ 这种，那么它就代表这个类型的指针

__char*__ 就是 __char__ 类型指针;

__int*__ 就是 __int__ 类型指针;

__float*__ 就是 __float__ 类型指针;

以此类推

// 32位系统下，所有的指针大小都为4字节；

```
*ptr = XW7 的家 ; 
 ptr = 0X12345678; 
```

但是如果它跟了变量名称，就比如上面的 __*ptr__ 那它就代表解引用了，就要使用代名词了。通俗的来讲给 __ptr__ 加上了 __*__ 就是把 __ptr__ 被加密了 只能说 __XW7的家__ ， 而不能将 __12市34区56街78号__ 这个确切的地址讲出来。即 __*ptr = XW7的家 , *ptr是XW7的家__。

## const与*的爱恨情仇

我相信很多人都因为 const和 * 的摆放位置而被搞得晕头转向过，不过当你抓住的精髓，你就会觉得非常的简单了。什么指针常量，常量指针的，一眼就可以分辨出来。

首先可能有人问，const是什么东西啊。哈哈， cosnt其实就是一个修饰词，被他修饰的东西不可以改变。

这里我分享一下我的小技巧：

### 技巧

首先我们列出来几种很常见的格式：
```
 const int * ptr；// 1
 int const * ptr；// 2
 int * const ptr；// 3
 ```

 我们要怎么来区分呢?很简单,我们只需要看两个东西，一个就是 __*__ 还有一个就是 __ptr__;

 如果const后面紧跟着的是 __*__ 那么毫无疑问 const 修饰了 * ，代表 *指向的东西不可以改变；//1,2

 如果const后面紧跟着的是 __变量名__ （即ptr），那么const就是修饰了变量名，代表变量名所代表的值不可以被改变。//3

 还有一件非常重要的事情，就是const是一次性的，要是想要多个不能被改变的指向或者值，就要使用多个const，如：
```
 const int* const ptr;  // int* 与 ptr 都不可变
 const int* const p1, const p2;  // int* p1 p2全都不可变
 ```


 ### 用途

 那么知道谁不可以改变以后，我们要用它们来干什么呢；首先我们从命名语句中可以得到两个比较有用的信息，一个是指针指向谁，还有一个就是指向的东西包含了什么内容。

 我们用租房子来举例子，指针代表房子，里面的内容代表租客；

 如果指向的东西不能改变，那现在就是房东身份，也就是说只要是我的房子就行，哪些租客无所谓，可以随意更换。

 如果指向的内容不能改变，那现在就是租客身份，也就是说只要是我在租房就行，哪间房子无所谓，可以随意更换。

 ### 延伸

 再往下延伸呢，应该就要触及到对象和类了，我们简单的说一下:
 ```
 const 返回类型 函数名 （参数）； // 表示我的返回类型不能修改
 返回类型 函数名 （const 参数）； // 表示我的传入参数不能修改
 返回类型 函数名 （参数）const ； // 表示我的类成员参数不能修改
 ```


 ## 数组与*的爱恨情仇

 我们都知道当数组被当做参数传入函数的的时候会被隐式的退化成指针，所以我们任性的把数组当成一种指针

 下面我们来说几种容易让人混淆的数组与*的组合：

 ### 示例

```
 int array[];
 int* p = array;
 *p ;            // array[0]
 p+1 ;           //array[0]的地址 + 4
 *p+1 ;          //array[0]的值 + 1
 *(p+1) ;        //array[1]

 *（ *（p+n)+m) = p[n][m];

```
 假设我们有一个数组叫array， *p =array; 那么：

 *p 代表了数组的第一个元素即 array[0],

  p + 1 代表了数组第一个元素的地址向后偏移一个单位的地址，如果array类型为 char 偏移量即为1，int偏移量为4 float 偏移量为4，以此类推。隐式的表示了数组第二个元素的地址。

 *p + 1 代表了数组第一个元素的值+1 即 array[0]的值 +1 

  *(p + 1 ) 代表了数组下标为1的元素 ,即 p[1]

  所以我们可以很简单的得出一个 *（p+n)=p[n]; // *( + ) =[]

  那如果是多员数组呢？

  很简单 *（ *（p+n)+m) = p[n][m];

  ## 指针操作

  永远都要记得在函数中 __只有下一级的指针才可以操作当前等级指针__，你可能有点蒙，我来给你解释一下：

  没有*的我们姑且称为零级指针

  *为一级指针

  **为二级指针

 这里有 p *p **p;

 那么 __*p__ 可以操作 __p__ ,__**p__ 可以操作 __*p__，以此类推

 如果你在尝试看懂一个多级指针，那么阅读顺序一定是从右往左的。
 
 __( * (* ( * (m)))__ 就比如这个,
 
 你要先看 __m__  然后看 __*（m）__;

 再看 __* (*(m))__;
 
 最后看 __*( * ( * (m)))__;

 千万不要想着一口吃一个胖子。

 ## 分享总结


 好了今天的分享就到这里了，要去忙了。

 这里分享一个比较不错的[指针教程](https://www.youtube.com/watch?v=h-HBipu_1P0&list=PL2_aWCzGMAwLZp6LMUKI3cc7pgGsasm2_)，希望可以对屏幕前的你有帮助；

 嘿嘿~

