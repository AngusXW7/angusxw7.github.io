[{"categories":["C++"],"content":"内存对齐","date":"2022-05-04","objectID":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/","tags":["C++","Memory Align"],"title":"内存对齐","uri":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["C++"],"content":"内存管理中很重要的一点，内存对齐！ ","date":"2022-05-04","objectID":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:0:0","tags":["C++","Memory Align"],"title":"内存对齐","uri":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["C++"],"content":"什么是内存对齐 首先我们知道每个数据都是有不同的大小的，可能是1,2,4,8 byte。而且每个数据元素也是按照他们定义的顺序一个一个放进内存的。大部分情况下数据的读取是以4为单位的，所以为了提高数据的读取速度，让数据不同的大小减少对数据读取速度的影响，我们开始使用内存对齐，并且可以用 #pragma pack(n) 来定义对齐系数。 从结构体存储的首地址开始，每个元素放置到内存中时，他们都会认为内存是按照自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始，这就是所谓的内存对齐。 ","date":"2022-05-04","objectID":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:1:0","tags":["C++","Memory Align"],"title":"内存对齐","uri":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["C++"],"content":"举个栗子 struct { int x; char y; } 当我问你们这个结构体占多大的时候，可能会有人不假思索的说出5 byte，但是实际上他占了8 byte;这时候就会问了，int占4 byte char 占 1 byte， 4+1=5啊，为什么会是8，这就是内存对齐所导致的了。 ","date":"2022-05-04","objectID":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:1:1","tags":["C++","Memory Align"],"title":"内存对齐","uri":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["C++"],"content":"为什么要内存对齐 平台原因： 不是所有的硬件平台都可以访问任意地址上的任意数据，所以为了更好的兼容性，我们要使用内存对齐； 性能原因： 当处理器按照自己的访问长度来访问未对齐的内存的时候，处理器需要访问两次内存，而如果对齐了的话只需要访问一次。 ","date":"2022-05-04","objectID":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:2:0","tags":["C++","Memory Align"],"title":"内存对齐","uri":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["C++"],"content":"内存对齐的规则 基本类型对齐的n就是sizeof得到的值； 数据成员对齐则是按照自身大小和 #pragma pack(n)中较小的那个进行； 结构或者联合整体对齐规则 是按照最大数据成员长度和 #pragma pack(n)中较小的那个进行。 // 一般默认n=4; ","date":"2022-05-04","objectID":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/:3:0","tags":["C++","Memory Align"],"title":"内存对齐","uri":"/zh-cn/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"categories":["C++"],"content":"内存泄漏 内存溢出 内存越界 栈溢出和内存碎片","date":"2022-04-20","objectID":"/zh-cn/memory/","tags":["C++","Memory"],"title":"内存机制中会出现的问题","uri":"/zh-cn/memory/"},{"categories":["C++"],"content":"内存机制中的常见问题！ 相信很多人在编程的时候都会多多少少的遇到内存问题，比如说非常常见的内存泄漏和内存溢出，那么今天我们就来聊一聊内存机制中我们可能会遇到的问题。 ","date":"2022-04-20","objectID":"/zh-cn/memory/:0:0","tags":["C++","Memory"],"title":"内存机制中会出现的问题","uri":"/zh-cn/memory/"},{"categories":["C++"],"content":"内存溢出 内存溢出是指程序在申请内存的时候没有足够的内存空间来让程序使用了。 我相信只要是写过程序的人肯定都遇到过内存泄漏这个问题，最容易出现这个问题的地方就是当我们调用了递归方程，但是递归方程算不完，又或者真的是数据量太过庞大导致内存真的不够用。这个时候我们的程序就会报出内存溢出这个错误。 ","date":"2022-04-20","objectID":"/zh-cn/memory/:1:0","tags":["C++","Memory"],"title":"内存机制中会出现的问题","uri":"/zh-cn/memory/"},{"categories":["C++"],"content":"内存泄漏 内存泄漏是指程序在申请内存后，无法释放已经申请的内存空间，占用有用的内存。 内存泄漏最终也会导致内存溢出。 ","date":"2022-04-20","objectID":"/zh-cn/memory/:2:0","tags":["C++","Memory"],"title":"内存机制中会出现的问题","uri":"/zh-cn/memory/"},{"categories":["C++"],"content":"内存泄漏分类 常发性内存泄漏 如果引起内存泄漏的代码被多次执行，那么每次执行该程序都会导致内存泄漏。 偶发性内存泄漏 在特定情况下执行引起内存泄露的代码，才会引起内存泄漏。 一次性内存泄漏 导致内存泄露的代码只会执行一次，这种情况多见于构造函数的时候，析构函数没有释放内存导致。 隐式泄漏 如果程序运行的时候不断地分配内存，直到结束才释放内存，也就是说我们没有及时的释放内存导致内存耗尽。 ","date":"2022-04-20","objectID":"/zh-cn/memory/:2:1","tags":["C++","Memory"],"title":"内存机制中会出现的问题","uri":"/zh-cn/memory/"},{"categories":["C++"],"content":"内存越界 简单来说就是向系统申请内存以后，实际使用的内存超出申请内存的范围。 ","date":"2022-04-20","objectID":"/zh-cn/memory/:3:0","tags":["C++","Memory"],"title":"内存机制中会出现的问题","uri":"/zh-cn/memory/"},{"categories":["C++"],"content":"栈溢出 首先我们知道栈是系统运行时候的一个小型自动分配的缓冲区，那当我们的数据量过于庞大，导致缓冲区装不下这么多数据的时候，就会造成栈溢出。 ","date":"2022-04-20","objectID":"/zh-cn/memory/:4:0","tags":["C++","Memory"],"title":"内存机制中会出现的问题","uri":"/zh-cn/memory/"},{"categories":["C++"],"content":"内存碎片 稍微了解一点内存分配的朋友应该都知道，当我们申请内存区域或者系统自动分配内存区域的时候，是随机寻找空间分配的，而不是连着分配区域的，那么这就造成了一个问题，那就是有些区域使用完毕以后被释放掉了，但是邻近的区域却被很小的数据占用着，当这样的碎片式小数据逐渐增多了以后，我们可以使用的连续的区域就会变少，可以被选择的连续存储区域也会变少，从而造成了内存碎片。 这些就是我知道的内存机制中我们会遇到的问题啦，如果你还直到别的问题，欢迎补充哦！ ","date":"2022-04-20","objectID":"/zh-cn/memory/:5:0","tags":["C++","Memory"],"title":"内存机制中会出现的问题","uri":"/zh-cn/memory/"},{"categories":["C++"],"content":"计算机内存分区","date":"2022-04-06","objectID":"/zh-cn/memory-division/","tags":["C++","“Memory Division\""],"title":"内存分区","uri":"/zh-cn/memory-division/"},{"categories":["C++"],"content":"计算机内存分区！ 首先我想说一下，有些资料会把内存分区分为四个区，有些资料会分为五个区。而我学习的是四区分区，相对来说我会更倾向于接受四区分区，但是当我查阅一些资料以后也开始理解了五区分区。 ","date":"2022-04-06","objectID":"/zh-cn/memory-division/:0:0","tags":["C++","“Memory Division\""],"title":"内存分区","uri":"/zh-cn/memory-division/"},{"categories":["C++"],"content":"四区分区 我们要知道一个C++编译出来的程序需要占用的内存分为以下几部分，他们分别是： 堆 ：这个内存区域一般是由程序猿，也就是我们主动分配的，程序结束的时候会由主动回收释放，我们经常进行的指针操作也是在这个区域内完成的； 栈：这个区域是由编译器自动分配释放的，一般存放函数参数，局部变量等； 全局静态区 ：全局变量和静态变量存放的区域，初始化的全局变量和静态变量是在一块区域，未初始化的全局变量和未初始化的静态变量是在相邻的另一块区域，这个区域也是程序结束后有系统自动释放； 代码区 ：这个区域就是纸面意思啦，就是我们所有的二进制代码都存放在这里。 ","date":"2022-04-06","objectID":"/zh-cn/memory-division/:1:0","tags":["C++","“Memory Division\""],"title":"内存分区","uri":"/zh-cn/memory-division/"},{"categories":["C++"],"content":"五区分区 对于五区分区呢只是多了一个常量存储区，即： 堆，栈，代码区，全局静态区 常量存储区：这个区域存放不允许被修改的常量，程序运行结束以后自动释放。 那为什么会造成这种分区差异呢，因为全局静态存储区存储的是 .bss 和 .data 段 ，而常量存储区存储的是 .data段，所以就出现了这种分区差异。 好了 以上就是今天的内容！ ","date":"2022-04-06","objectID":"/zh-cn/memory-division/:2:0","tags":["C++","“Memory Division\""],"title":"内存分区","uri":"/zh-cn/memory-division/"},{"categories":["C++"],"content":"C语言中的关键字","date":"2022-03-23","objectID":"/zh-cn/keyword/","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"C语言中的关键字！ 今天我们来说一下C语言中的关键字 ","date":"2022-03-23","objectID":"/zh-cn/keyword/:0:0","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"关键字是什么 那在说关键字之前，首先我们要知道关键字的定义是什么。 关键字就是具有特殊意义的预定义保留标识符，它们不能用作程序中的标识符。我们常见的关键字有 ","date":"2022-03-23","objectID":"/zh-cn/keyword/:1:0","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"关键字有哪些 关键字一览表关键字 \"\r关键字一览表\r 这是我从网上找到的C++ 98/03关键字一览表，其中红色标注的是C语言的32个关键字。 而C++ 11中是有73个关键字的，新增的是个分别是 alignas、alignof、char16_t、char32_t、constexpr、decltype、noexpect、nullptr、static_assert、thread_local 接下来我们对比较常用的关键字进行简单的解释 ","date":"2022-03-23","objectID":"/zh-cn/keyword/:1:1","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"auto 这个关键词用法就像它的名字一样，会自动腿短变量的数据类型，但是我们要注意，不是每个编译器都支持auto的 auto x=1; // 这里使用整数1对变量x进行初始化，那么x的类型就被推断为int 整数型。 auto y=3.14159; // 这里使用浮点数3.14159对变量y进行初始化，那么y的类型就会被推断为float 浮点数类型。 ","date":"2022-03-23","objectID":"/zh-cn/keyword/:1:2","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"***_cast 后面加上cast的关键字是C++风格的类型转换 const_cast const_cast就比较简单了，它就是删除const变量的属性，使得被转换的数据类型可以被改变 dynamic_cast dynamic_cast是将父类对象指针转换为子类对象指针或者引用，是一种自上而下的转换方式 static_cast 相对于dynamic_cast，static_cast大多数用于子类对象指针向父类对象转换的情况，是一种自下而上的转换方式 reinterpret_cast reinterpret_cast是比较危险的一种转换，它可以将一种类型转换成另一种不同的类型，可以作用于两个完全不相关的类型转换 ","date":"2022-03-23","objectID":"/zh-cn/keyword/:1:3","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"break 、 continue 我身边的小伙伴经常会把这两个关键字搞混，其实我们只需要理解字面意思就好了，break就是停下，顾名思义就是跳出当前的循环，不再继续这个循环了，直接进行下一步，而continue就是继续，也就是说跳过本次循环，继续下一次循环。 ","date":"2022-03-23","objectID":"/zh-cn/keyword/:1:4","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"do、for、while 他们是循环语句组成部分，C和C++都支持。 ","date":"2022-03-23","objectID":"/zh-cn/keyword/:1:5","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"if else 这两个是条件语句的组成部分，if表示满足什么条件，else一般就是不满足这个条件。 ","date":"2022-03-23","objectID":"/zh-cn/keyword/:1:6","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"public、private、protected、friend 大家应该对这些关键字不陌生 private 私有，只能在本类，派生类和友元中访问 public 公有，访问不受限制，任何类都可以访问 protected 保护，只有本类和友元可以访问 friend 友元，使其不受访问权限控制的限制。其实友元的存在破坏了C++的封装性，建议大家减少有友元的使用 好了，这就是今天的内容！ 希望屏幕前的你喜欢！ ","date":"2022-03-23","objectID":"/zh-cn/keyword/:1:7","tags":["C++","Keyword"],"title":"C++ 关键字","uri":"/zh-cn/keyword/"},{"categories":["C++"],"content":"C++ 类与它的六种成员函数","date":"2022-03-16","objectID":"/zh-cn/special-member/","tags":["C++","Class","memberFunctions"],"title":"类与成员函数","uri":"/zh-cn/special-member/"},{"categories":["C++"],"content":"C++类与它的六种成员函数！ 用户创建的函数与系统默认生成的函数的关系图函数关系图 \"\r用户创建的函数与系统默认生成的函数的关系图\r ","date":"2022-03-16","objectID":"/zh-cn/special-member/:0:0","tags":["C++","Class","memberFunctions"],"title":"类与成员函数","uri":"/zh-cn/special-member/"},{"categories":["C++"],"content":"六大成员函数 我们都知道面向对象编程是C++的一个特点，这些对象大部分都是有对应的类的，而类中也有很重要的函数，就是我们今天要讨论的成员函数。 从上图中我们可以看出，一共有六种成员函数，他们分别是： class A { public: A(); //构造函数 ~A(); //析构函数 A(const A\u0026 a); //复制构造函数 A(const\u0026\u0026 a); //移动构造函数 A\u0026 operator=(const A\u0026 a); //复制运算符 A\u0026 operator=(A\u0026\u0026 a); //移动运算符 } 结合图中的文字我们可以很轻易地看出，当我们一个函数都不声明的时候，系统是会自动帮我们声明这些函数的；但是一旦当我们声明了这些函数以后，系统就会删除自动声明的那些函数。 简单一点来说，如果我们没有，系统就用自己的；如果我们有，系统就用我们的。 这里结合类的特性说几点比较重要的东西： 构造函数一定不能是虚函数！ 因为构造函数是创造对象的，而虚函数需要知道对象的实际类型，如果构造函数被定义为虚函数了，那么就无法知道对象的实际类型了！ 如果有条件析构函数最好是虚函数！ 析构函数定义成了虚函数可以很好地解决父类子类进行类型转换以后的析构操作，避免造成析构了错误对象或者说没有析构该析构的对象。 ","date":"2022-03-16","objectID":"/zh-cn/special-member/:1:0","tags":["C++","Class","memberFunctions"],"title":"类与成员函数","uri":"/zh-cn/special-member/"},{"categories":["C++"],"content":"0/3/5法则 接下来我们来说一下0/3/5法则，可能根据字面意思聪明的你就知道这是什么东西了，没错！就是我们需要添加几个函数。 ","date":"2022-03-16","objectID":"/zh-cn/special-member/:2:0","tags":["C++","Class","memberFunctions"],"title":"类与成员函数","uri":"/zh-cn/special-member/"},{"categories":["C++"],"content":"0法则 0法则顾名思义就是一个成员函数都不要定义，因为很多时候类并不需要析构函数，复制/移动构造函数或者复制/移动运算符，编译器默认生成的就可以很好地完成任务了，所以如果有可能的话，尽量使用零规则。 class A { public: // 0法则 } ","date":"2022-03-16","objectID":"/zh-cn/special-member/:2:1","tags":["C++","Class","memberFunctions"],"title":"类与成员函数","uri":"/zh-cn/special-member/"},{"categories":["C++"],"content":"3法则 如果你定义了复制操作，那么要记得重写复制操作相关的方程，否则有的时候编译器会调用移动方程，因为在它看来移动操作比复制操作会好很多。 class A { public: ~A();//析构函数 A(const A\u0026 a); //复制构造函数 A\u0026 operator=(const A\u0026 a); //复制运算符 } ","date":"2022-03-16","objectID":"/zh-cn/special-member/:2:2","tags":["C++","Class","memberFunctions"],"title":"类与成员函数","uri":"/zh-cn/special-member/"},{"categories":["C++"],"content":"5法则 这个法则比较重要，如果说你自己定义了一个析构函数，那么你就必须要自己把复制构造函数和复制运算符也定义了，否则默认生成的复制构造函数和复制运算符会做错事情；同时还要编写具有匹配语义的构造函数和复制运算符。然后出于对性能的考虑，移动构造函数课移动运算符最好也自己同时编写。 class A { public: A(); ~A(); A(const A\u0026 a); A(const\u0026\u0026 a); A\u0026 operator=(const A\u0026 a); A\u0026 operator=(A\u0026\u0026 a); } 好啦，那今天就分享这么多吧！临近期末了，比较忙，偷个懒。 嘿嘿！ ","date":"2022-03-16","objectID":"/zh-cn/special-member/:2:3","tags":["C++","Class","memberFunctions"],"title":"类与成员函数","uri":"/zh-cn/special-member/"},{"categories":["C++"],"content":"关于C指针的一点拙见","date":"2022-03-09","objectID":"/zh-cn/c_pointer/","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"C系列语言的精髓 指针！ 哈喽，我又在百忙之中抽出时间如约而至啦。今天来浅谈一下指针吧，都说C的精髓就是指针，不过也确实，C应该是为数不多可以凭借指针操控底层内存的高级语言了。我的理解程度肯定没有大神级别的那么深，毕竟是个刚入门的小白，用词不准确或者逻辑不严谨的话，还请多指教啦~，如果有哪里说的不对，也欢迎指出！ ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:0:0","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"指针是什么 那展开问题之前，我们要先搞清楚指针是什么。 我们经常说，指针就是地址，指针变量是用来存放内存地址的变量的。 我的理解呢，指针就相当于你家的代名词，而内存地址就是你家实际在的地方。常说的指针指向了某某地址，其实就是在说，你家这个代名词说明了你家地址所在地（就是你家住哪）。这样讲听着有点像废话。 ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:1:0","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"我们还是来举个例子吧： int* ptr= 0X12345678; int* ptr = \u0026 XW7的家; 我们有一个整形指针 ptr （我家代名词）： int* ptr ; 这个指针指向了（我家实际地址）：0X12345678; //一般情况下内存地址用八位的十六进制表示，0X开头是为了和二进制，八进制还有十进制作区分 一般写成 int* ptr = \u0026 XW7的家; 我们先忽略这个 “\u0026” ，把 “=” 读作 “是” ，那么现在这句话是不是就在说 ptr 是 xw7的家。 接下来，比如我要邀请我的朋友周末来我家玩，那我光和他说 ptr 他肯定不能平白无故的知道我家在哪，对吧。 所以我们要用“\u0026”表示地址，那么int* ptr = \u0026 XW7的家 现在就变成了 ptr = 12市34区56街78号，即我家的实际地址，同样的，我们把“=”读作“是”，XW7的家是12市34区56街78号。这样我的朋友们周末就可以顺利的找到我家了。 ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:1:1","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"“*” int* *ptr //不存在 int* ptr = 什么 ; ptr* = 什么 ; “*“这个符号呢跟随不同的主人，就会代表不同的意思，我们俗称嫁鸡随鸡嫁狗随狗。 但是我们不会看见int* * 变量名（int* *ptr） 这种东西存在的； 我们只会看到int* 变量名 = 什么; 或者 *ptr = 什么; char* c ;//char类型指针 int* i ;//int类型指针 float* f ;//float类型指针 一般情况下，如果它跟的是数据类型，比如 char int float 这种，那么它就代表这个类型的指针 char* 就是 char 类型指针; int* 就是 int 类型指针; float* 就是 float 类型指针; 以此类推 // 32位系统下，所有的指针大小都为4字节； *ptr = XW7 的家 ; ptr = 0X12345678; 但是如果它跟了变量名称，就比如上面的 *ptr 那它就代表解引用了，就要使用代名词了。通俗的来讲给 ptr 加上了 * 就是把 ptr 被加密了 只能说 XW7的家 ， 而不能将 12市34区56街78号 这个确切的地址讲出来。即 *ptr = XW7的家 , *ptr是XW7的家。 ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:1:2","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"const与*的爱恨情仇 我相信很多人都因为 const和 * 的摆放位置而被搞得晕头转向过，不过当你抓住的精髓，你就会觉得非常的简单了。什么指针常量，常量指针的，一眼就可以分辨出来。 首先可能有人问，const是什么东西啊。哈哈， cosnt其实就是一个修饰词，被他修饰的东西不可以改变。 这里我分享一下我的小技巧： ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:2:0","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"技巧 首先我们列出来几种很常见的格式： const int * ptr；// 1 int const * ptr；// 2 int * const ptr；// 3 我们要怎么来区分呢?很简单,我们只需要看两个东西，一个就是 * 还有一个就是 ptr; 如果const后面紧跟着的是 * 那么毫无疑问 const 修饰了 *ptr ，代表 *ptr(内容)不可以改变；//1,2 如果const后面紧跟着的是 变量名 （即ptr），那么const就是修饰了变量名，代表ptr(指针)不可以被改变。//3 还有一件非常重要的事情，就是const是一次性的，要是想要多个不能被改变的指向或者值，就要使用多个const，如： const int* const ptr; // int* 与 ptr 都不可变 const int* const p1, const p2; // int* p1 p2全都不可变 ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:2:1","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"用途 那么知道谁不可以改变以后，我们要用它们来干什么呢；首先我们从命名语句中可以得到两个比较有用的信息，一个是指针指向谁，还有一个就是指向的东西包含了什么内容。 我们用租房子来举例子，指针代表房子，里面的内容代表租客； 如果指向的东西不能改变，那现在就是房东身份，也就是说只要是我的房子就行，哪些租客无所谓，可以随意更换。 如果指向的内容不能改变，那现在就是租客身份，也就是说只要是我在租房就行，哪间房子无所谓，可以随意更换。 ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:2:2","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"延伸 再往下延伸呢，应该就要触及到对象和类了，我们简单的说一下: const 返回类型 函数名 （参数）； // 表示我的返回类型不能修改 返回类型 函数名 （const 参数）； // 表示我的传入参数不能修改 返回类型 函数名 （参数）const ； // 表示我的类成员参数不能修改 ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:2:3","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"数组与*的爱恨情仇 我们都知道当数组被当做参数传入函数的的时候会被隐式的退化成指针，所以我们任性的把数组当成一种指针 下面我们来说几种容易让人混淆的数组与*的组合： ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:3:0","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"示例 int array[]; int* p = array; *p ; // array[0] p+1 ; //array[0]的地址 + 4 *p+1 ; //array[0]的值 + 1 *(p+1) ; //array[1] *（ *（p+n)+m) = p[n][m]; 假设我们有一个数组叫array， *p =array; 那么： *p 代表了数组的第一个元素即 array[0], p + 1 代表了数组第一个元素的地址向后偏移一个单位的地址，如果array类型为 char 偏移量即为1，int偏移量为4 float 偏移量为4，以此类推。隐式的表示了数组第二个元素的地址。 *p + 1 代表了数组第一个元素的值+1 即 array[0]的值 +1 *(p + 1 ) 代表了数组下标为1的元素 ,即 p[1] 所以我们可以很简单的得出一个 *（p+n)=p[n]; // *( + ) =[] 那如果是多员数组呢？ 很简单 *（ *（p+n)+m) = p[n][m]; ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:3:1","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"指针操作 永远都要记得在函数中 只有下一级的指针才可以操作当前等级指针，你可能有点蒙，我来给你解释一下： 没有*的我们姑且称为零级指针 *为一级指针 **为二级指针 这里有 p *p **p; 那么 *p 可以操作 p ,**p 可以操作 *p，以此类推 如果你在尝试看懂一个多级指针，那么阅读顺序一定是从右往左的。 ( * (* ( * (m))) 就比如这个, 你要先看 m 然后看 *（m）; 再看 * (*(m)); 最后看 *( * ( * (m))); 千万不要想着一口吃一个胖子。 ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:4:0","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["C++"],"content":"分享总结 好了今天的分享就到这里了，要去忙了。 这里分享一个比较不错的指针教程，希望可以对屏幕前的你有帮助； 嘿嘿~ ","date":"2022-03-09","objectID":"/zh-cn/c_pointer/:5:0","tags":["Pointer","C++","essence"],"title":"C++ 指针","uri":"/zh-cn/c_pointer/"},{"categories":["general"],"content":"人生中的第一篇博客，还是抽出来时间写的","date":"2022-03-02","objectID":"/zh-cn/hello-world/","tags":["hello-world","general","others"],"title":"你好，世界！","uri":"/zh-cn/hello-world/"},{"categories":["general"],"content":"你好，屏幕面前的你！ 首先很感谢你能来到我的博客，这是我第一次尝试来搭建博客并在上面用makedown语法编辑文章，我希望在这里你可以见证我的成长，我的改变。同时也可以和我一起见证这个博客从零到一，从无到有的过程。 准备了半个月终于把网站的基础建设都设置好了，本来这篇文章是想在3月1号发出来的，作为一个月的开始，也是这个网站的开始，肯定是一个很不错的日子。只可惜啊，真的是太忙了，刚刚腾出来点时间写这篇博客，刚开始创建了这个文档的时候竟然不知道名字该叫什么，内容该写一些什么，哈哈。毕竟平时也很少写东西分享东西，突然有那么一点蒙蒙的。 既然是程序员，那肯定所有人都是从一句“Hello World！”开始的，所以我的博客也将从“你好，世界！”开始，希望中间不会出现‘break’或者‘sleep’。 博客里的内容，我的初步设想是分为虚幻引擎游戏制作，C++生活和普通三个大板块，毕竟咱是游戏软件编程出身，学习的C++和虚幻引擎，初来乍到一个陌生的领域，肯定得先从自己熟悉的东西开始写才会比较容易产出内容。当然，日后如果觉得有什么东西很有趣，也会成为新的板块加入到我博客的大家庭中。 好了，就先说这么多吧，要赶紧去忙了。如果你对我比较感兴趣，想进一步了解我的话，可以点击右上角的“关于XW7\u0026”来查看我的个人资料。个人资料肯定是会持续更新的，毕竟人都在成长，经历和能力还有作品都会随着时间的推移越来越丰富的。 嘿嘿~ ","date":"2022-03-02","objectID":"/zh-cn/hello-world/:0:0","tags":["hello-world","general","others"],"title":"你好，世界！","uri":"/zh-cn/hello-world/"},{"categories":null,"content":"This is for test. ","date":"2022-02-15","objectID":"/zh-cn/testblog/:0:0","tags":null,"title":"TestBlog","uri":"/zh-cn/testblog/"},{"categories":null,"content":"class XW7\u0026 struct 基本信息 { 专业 : 游戏设计与软件编程； 擅长语言 : C++ //从入学老师就教的C++ ； 梦想 : 做出一款让人自然而然就会喜欢上的MMORPG国风游戏(汉服YYDS！)； 性格 : 待人宽容，对人友善，尊有德之老，爱有教之幼，活泼开朗，慢热型人格，对待事情认真负责，待人宽容且耐心，具有团队合作精神，往往能提出意想不到且富有创造性的提议； 兴趣爱好 : 打游戏，听歌，旅行，看别人拍的照片，看别人吃美食，喜欢各种有趣、带有科技感的小玩意（比如：无人机）； 偏爱城市 : 海南，珠海，西安； … ; } struct 个人技能 { 熟悉 C++，了解部分14/17/20新特性,具有Debug能力； 熟悉 Unreal Engine 4 ，并有个人独立开发的完整作品； 掌握 数据结构与算法，具有良好的编程习惯； 掌握 MySQL的基本应用 //CRUD； 了解 Golang基本语法和简单的使用； 了解 Unreal Engine 5，已尝试使用了UE5抢先体验版，并进行学习； 了解 Unity3D对于手机游戏的开发，并有自己的作品[]； 了解 计算机网络基础知识，比如TCP/IP、socket等； 了解 MAYA基础的建模以及Nuke和Renderman对做出来的建模进行渲染与制作视频； 了解 Linux操作系统，基本掌握日常使用； const 一大波全新的技能正在路上！； } struct 作品 { UE4 开放世界游戏Demo； C++ 游戏引擎; Golang { 日志; ini配置文件解析器; } } struct 联系方式 { QQ : 714152655; 邮箱 : angusli951102@gmail.com； github; Steam; 领英; 微博; 哔哩哔哩; } ","date":"0001-01-01","objectID":"/zh-cn/about/:0:1","tags":null,"title":"关于 XW7\u0026","uri":"/zh-cn/about/"}]